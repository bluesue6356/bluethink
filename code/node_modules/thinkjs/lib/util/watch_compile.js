'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * watch compile
 */

var _class = function () {
  /**
   * constructor
   * @param  {Array} args []
   * @return {}         []
   */

  /**
   * compiled error files
   * @type {Array}
   */

  function _class() {
    (0, _classCallCheck3.default)(this, _class);
    this.compiledMtime = {};
    this.compiledErrorFiles = [];
    this.allowFileExt = ['.js', '.ts'];

    this.init.apply(this, arguments);
  }
  /**
   * init
   * @param  {String} srcPath []
   * @param  {String} outPath []
   * @param  {Boolean} log     []
   * @return {}         []
   */

  /**
   * allow file ext in src path
   * @type {Array}
   */

  /**
   * store compiled files last mtime
   * @type {Object}
   */


  _class.prototype.init = function init(srcPath, outPath) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
    var callback = arguments[3];

    this.srcPath = _path2.default.normalize(srcPath);
    this.outPath = _path2.default.normalize(outPath);
    this.options = options;
    this.callback = callback;
  };
  /**
   * compile single file
   * @param  {String} file     []
   * @param  {Boolean} onlyCopy []
   * @return {}          []
   */


  _class.prototype.compileFile = function compileFile(file, onlyCopy) {
    var filePath = '' + this.srcPath + think.sep + file;
    var content = _fs2.default.readFileSync(filePath, 'utf8');

    //when get file content empty, maybe file is locked
    if (!content) {
      return;
    }
    // only copy file content
    if (onlyCopy) {
      var saveFilepath = '' + this.outPath + think.sep + file;
      think.mkdir(_path2.default.dirname(saveFilepath));
      _fs2.default.writeFileSync(saveFilepath, content);
      return;
    }

    try {
      if (this.options.type === 'ts') {
        this.compileByTypeScript(content, file);
      } else {
        this.compileByBabel(content, file);
      }
      return true;
    } catch (e) {

      think.log(function (colors) {
        return colors.red('compile file ' + file + ' error');
      }, 'COMPILE');
      think.log(e);

      e.message = 'Compile Error: ' + e.message;
      think.compileError = e;
    }
    return false;
  };
  /**
   * typescript compile
   * @return {} []
   */


  _class.prototype.compileByTypeScript = function compileByTypeScript(content, file) {
    var ts = require('typescript');
    var startTime = Date.now();
    var diagnostics = [];
    var result = ts.transpile(content, {
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.ES6,
      experimentalDecorators: true,
      emitDecoratorMetadata: true,
      allowSyntheticDefaultImports: true
    }, file, diagnostics);
    //has error
    if (diagnostics.length) {
      var firstDiagnostics = diagnostics[0];

      var _firstDiagnostics$fil = firstDiagnostics.file.getLineAndCharacterOfPosition(firstDiagnostics.start);

      var line = _firstDiagnostics$fil.line;
      var character = _firstDiagnostics$fil.character;

      var message = ts.flattenDiagnosticMessageText(firstDiagnostics.messageText, '\n');
      throw new Error(message + ' on Line ' + (line + 1) + ', Character ' + character);
    }
    if (this.options.log) {
      think.log('Compile file ' + file, 'TypeScript', startTime);
    }
    file = this.replaceExtName(file, '.js');
    this.compileByBabel(result, file, true);
  };
  /**
   * babel compile
   * @return {} []
   */


  _class.prototype.compileByBabel = function compileByBabel(content, file, logged) {
    var startTime = Date.now();
    var retainLines = this.options.retainLines;
    //babel not export default property
    //so can not use `import babel from 'babel-core'`
    var babel = require('babel-core');
    var data = babel.transform(content, {
      filename: file,
      retainLines: retainLines,
      presets: ['es2015-loose', 'stage-1'].concat(this.options.presets || []),
      plugins: ['transform-runtime'].concat(this.options.plugins || [])
    });
    if (!logged && this.options.log) {
      think.log('Compile file ' + file, 'Babel', startTime);
    }
    think.mkdir(_path2.default.dirname('' + this.outPath + think.sep + file));
    _fs2.default.writeFileSync('' + this.outPath + think.sep + file, data.code);
  };
  /**
   * src file is deleted, but app file also exist
   * then delete app file
   * @return {} []
   */


  _class.prototype.getSrcDeletedFiles = function getSrcDeletedFiles(srcFiles, appFiles) {
    var _this = this;

    var srcFilesWithoutExt = srcFiles.map(function (item) {
      return _this.replaceExtName(item);
    });
    return appFiles.filter(function (file) {
      var extname = _path2.default.extname(file);
      if (_this.allowFileExt.indexOf(extname) === -1) {
        return;
      }
      var fileWithoutExt = _this.replaceExtName(file);
      //src file not exist
      if (srcFilesWithoutExt.indexOf(fileWithoutExt) === -1) {
        var filepath = _this.outPath + think.sep + file;
        if (think.isFile(filepath)) {
          _fs2.default.unlinkSync(filepath);
        }
        return true;
      }
    }).map(function (file) {
      return _this.outPath + think.sep + file;
    });
  };
  /**
   * replace filepath extname
   * @param  {String} filepath []
   * @param  {String} extname  []
   * @return {String}          []
   */


  _class.prototype.replaceExtName = function replaceExtName(filepath) {
    var extname = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

    return filepath.replace(/\.\w+$/, extname);
  };
  /**
   * compile
   * @return {} []
   */


  _class.prototype.compile = function compile(once) {
    var _this2 = this;

    var files = think.getFiles(this.srcPath, true);
    var appFiles = think.getFiles(this.outPath, true);
    var changedFiles = this.getSrcDeletedFiles(files, appFiles);

    if (!this.compiledErrorFiles.length) {
      think.compileError = null;
    }

    files.forEach(function (file) {
      var extname = _path2.default.extname(file);
      //if is not js file, only copy
      if (_this2.allowFileExt.indexOf(extname) === -1) {
        _this2.compileFile(file, true);
        return;
      }
      var mTime = _fs2.default.statSync('' + _this2.srcPath + think.sep + file).mtime.getTime();
      var outFile = '' + _this2.outPath + think.sep + file;

      //change extname to .js.
      //in typescript, file extname is .ts
      outFile = _this2.replaceExtName(outFile, '.js');

      if (think.isFile(outFile)) {
        var outmTime = _fs2.default.statSync(outFile).mtime.getTime();
        //if compiled file mtime is after than source file, return
        if (outmTime >= mTime) {
          return;
        }
      }
      if (!_this2.compiledMtime[file] || mTime > _this2.compiledMtime[file]) {
        var ret = _this2.compileFile(file);
        if (ret) {
          changedFiles.push(outFile);
        }

        _this2.compiledMtime[file] = mTime;

        if (ret) {
          var index = _this2.compiledErrorFiles.indexOf(file);
          if (index > -1) {
            _this2.compiledErrorFiles.splice(index, 1);
          }
        } else {
          _this2.compiledErrorFiles.push(file);
        }
      }
    });
    //notify auto reload service to clear file cache
    if (changedFiles.length && this.callback) {
      this.callback(changedFiles);
    }
    if (!once) {
      setTimeout(this.compile.bind(this), 100);
    }
  };
  /**
   * run
   * @return {} []
   */


  _class.prototype.run = function run() {
    this.compile();
  };
  /**
   * compile
   * @return {} []
   */


  _class.compile = function compile(srcPath, outPath) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var instance = new this(srcPath, outPath, options);
    instance.compile(true);
  };

  return _class;
}();

exports.default = _class;